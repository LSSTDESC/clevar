Matching catalogs based on proximity (simple)
=============================================

Matching two catalogs based on proximity based on a configuration
dictionary

.. raw:: html

   <h1>

Table of Contents

.. raw:: html

   </h1>

.. container:: toc

   .. raw:: html

      <ul class="toc-item">

   .. raw:: html

      <li>

   1  ClCatalogs

   .. raw:: html

      </li>

   .. raw:: html

      <li>

   2  Matching

   .. raw:: html

      </li>

   .. raw:: html

      <li>

   3  Save and Load

   .. raw:: html

      </li>

   .. raw:: html

      <li>

   4  Getting Matched Pairs

   .. raw:: html

      </li>

   .. raw:: html

      <li>

   5  Outputing matched catalogs

   .. raw:: html

      <ul class="toc-item">

   .. raw:: html

      <li>

   5.1  Outputing matching information to original catalogs

   .. raw:: html

      </li>

   .. raw:: html

      </ul>

   .. raw:: html

      </li>

   .. raw:: html

      </ul>

.. code:: ipython3

    %load_ext autoreload
    %autoreload 2

ClCatalogs
----------

Given some input data

.. code:: ipython3

    import numpy as np
    from astropy.table import Table
    input1 = Table({ 
        'ID': [f'CL{i}' for i in range(5)],
        'RA': [0.0, 0.0001, 0.00011, 25, 20],
        'DEC': [0.0, 0.0, 0.0, 0.0, 0.0],
        'Z': [0.2, 0.3, 0.25, 0.4, 0.35],
        'MASS': [10**13.5, 10**13.4, 10**13.3, 10**13.8, 10**14],
        'RADIUS_ARCMIN': [1.0, 1.0, 1.0, 1.0, 1.0],
    })
    input2 = Table({
        'ID': ['CL0', 'CL1', 'CL2', 'CL3'],
        'RA': [0.0, 0.0001, 0.00011, 25],
        'DEC': [0.0, 0, 0, 0],
        'Z': [0.3, 0.2, 0.25, 0.4],
        'MASS': [10**13.3, 10**13.4, 10**13.5, 10**13.8],
        'RADIUS_ARCMIN': [1.0, 1.0, 1.0, 1.0],
    })
    display(input1)
    display(input2)



.. raw:: html

    <div><i>Table length=5</i>
    <table id="table140462142860016" class="table-striped table-bordered table-condensed">
    <thead><tr><th>ID</th><th>RA</th><th>DEC</th><th>Z</th><th>MASS</th><th>RADIUS_ARCMIN</th></tr></thead>
    <thead><tr><th>str3</th><th>float64</th><th>float64</th><th>float64</th><th>float64</th><th>float64</th></tr></thead>
    <tr><td>CL0</td><td>0.0</td><td>0.0</td><td>0.2</td><td>31622776601683.793</td><td>1.0</td></tr>
    <tr><td>CL1</td><td>0.0001</td><td>0.0</td><td>0.3</td><td>25118864315095.82</td><td>1.0</td></tr>
    <tr><td>CL2</td><td>0.00011</td><td>0.0</td><td>0.25</td><td>19952623149688.83</td><td>1.0</td></tr>
    <tr><td>CL3</td><td>25.0</td><td>0.0</td><td>0.4</td><td>63095734448019.43</td><td>1.0</td></tr>
    <tr><td>CL4</td><td>20.0</td><td>0.0</td><td>0.35</td><td>100000000000000.0</td><td>1.0</td></tr>
    </table></div>



.. raw:: html

    <div><i>Table length=4</i>
    <table id="table140462142860832" class="table-striped table-bordered table-condensed">
    <thead><tr><th>ID</th><th>RA</th><th>DEC</th><th>Z</th><th>MASS</th><th>RADIUS_ARCMIN</th></tr></thead>
    <thead><tr><th>str3</th><th>float64</th><th>float64</th><th>float64</th><th>float64</th><th>float64</th></tr></thead>
    <tr><td>CL0</td><td>0.0</td><td>0.0</td><td>0.3</td><td>19952623149688.83</td><td>1.0</td></tr>
    <tr><td>CL1</td><td>0.0001</td><td>0.0</td><td>0.2</td><td>25118864315095.82</td><td>1.0</td></tr>
    <tr><td>CL2</td><td>0.00011</td><td>0.0</td><td>0.25</td><td>31622776601683.793</td><td>1.0</td></tr>
    <tr><td>CL3</td><td>25.0</td><td>0.0</td><td>0.4</td><td>63095734448019.43</td><td>1.0</td></tr>
    </table></div>


Create two ``ClCatalog`` objects, they have the same properties of
``astropy`` tables with additional functionality. For the proximity
matching, the main columns to be included are: -
``id - if not included, one will be assigned -``\ ra\ ``(in degrees) - necessary -``\ dec\ ``(in degrees) - necessary -``\ z\ ``- necessary if used as matching criteria or for angular to physical convertion -``\ mass\ ``(or mass proxy) - necessary if used as preference criteria for unique matches -``\ radius\ ``- necessary if used as a criteria of matching (also requires``\ radius_unit\`
to be passed)

.. code:: ipython3

    from clevar.catalog import ClCatalog
    c1 = ClCatalog('Cat1', id=input1['ID'], ra=input1['RA'], dec=input1['DEC'], z=input1['Z'], mass=input1['MASS'])
    c2 = ClCatalog('Cat2', id=input2['ID'], ra=input2['RA'], dec=input2['DEC'], z=input2['Z'], mass=input2['MASS'])
    # Format for nice display
    for c in ('ra', 'dec', 'z'):
        c1[c].info.format = '.2f'
        c2[c].info.format = '.2f'
    for c in ('mass',):
        c1[c].info.format = '.2e'
        c2[c].info.format = '.2e'
    display(c1)
    display(c2)



.. raw:: html

    <b>Cat1</b><br></b><b>tags:</b> id(id), ra(ra), dec(dec), z(z), mass(mass)<br><b>Radius unit:</b> None<br><div><i>ClData length=5</i>
    <table id="table140461232685936" class="table-striped table-bordered table-condensed">
    <thead><tr><th>id</th><th>ra</th><th>dec</th><th>z</th><th>mass</th><th>mt_self</th><th>mt_other</th><th>mt_multi_self</th><th>mt_multi_other</th></tr></thead>
    <thead><tr><th>str3</th><th>float64</th><th>float64</th><th>float64</th><th>float64</th><th>object</th><th>object</th><th>object</th><th>object</th></tr></thead>
    <tr><td>CL0</td><td>0.00</td><td>0.00</td><td>0.20</td><td>3.16e+13</td><td>None</td><td>None</td><td>[]</td><td>[]</td></tr>
    <tr><td>CL1</td><td>0.00</td><td>0.00</td><td>0.30</td><td>2.51e+13</td><td>None</td><td>None</td><td>[]</td><td>[]</td></tr>
    <tr><td>CL2</td><td>0.00</td><td>0.00</td><td>0.25</td><td>2.00e+13</td><td>None</td><td>None</td><td>[]</td><td>[]</td></tr>
    <tr><td>CL3</td><td>25.00</td><td>0.00</td><td>0.40</td><td>6.31e+13</td><td>None</td><td>None</td><td>[]</td><td>[]</td></tr>
    <tr><td>CL4</td><td>20.00</td><td>0.00</td><td>0.35</td><td>1.00e+14</td><td>None</td><td>None</td><td>[]</td><td>[]</td></tr>
    </table></div>



.. raw:: html

    <b>Cat2</b><br></b><b>tags:</b> id(id), ra(ra), dec(dec), z(z), mass(mass)<br><b>Radius unit:</b> None<br><div><i>ClData length=4</i>
    <table id="table140460608097344" class="table-striped table-bordered table-condensed">
    <thead><tr><th>id</th><th>ra</th><th>dec</th><th>z</th><th>mass</th><th>mt_self</th><th>mt_other</th><th>mt_multi_self</th><th>mt_multi_other</th></tr></thead>
    <thead><tr><th>str3</th><th>float64</th><th>float64</th><th>float64</th><th>float64</th><th>object</th><th>object</th><th>object</th><th>object</th></tr></thead>
    <tr><td>CL0</td><td>0.00</td><td>0.00</td><td>0.30</td><td>2.00e+13</td><td>None</td><td>None</td><td>[]</td><td>[]</td></tr>
    <tr><td>CL1</td><td>0.00</td><td>0.00</td><td>0.20</td><td>2.51e+13</td><td>None</td><td>None</td><td>[]</td><td>[]</td></tr>
    <tr><td>CL2</td><td>0.00</td><td>0.00</td><td>0.25</td><td>3.16e+13</td><td>None</td><td>None</td><td>[]</td><td>[]</td></tr>
    <tr><td>CL3</td><td>25.00</td><td>0.00</td><td>0.40</td><td>6.31e+13</td><td>None</td><td>None</td><td>[]</td><td>[]</td></tr>
    </table></div>


The ``ClCatalog`` object can also be read directly from a file, for
details, see catalogs.ipynb.

Matching
--------

Import the ``ProximityMatch`` and create a object for matching

.. code:: ipython3

    from clevar.match import ProximityMatch
    mt = ProximityMatch()

Prepare the configuration. The main values are:

-  ``type``: Type of matching to be considered. Can be a simple match of
   ClCatalog1->ClCatalog2 (``cat1``), ClCatalog2->ClCatalog1 (``cat2``)
   or cross matching.
-  ``which_radius``: Given a pair of clusters, which radius will be used
   for the matching.
-  ``preference``: In cases where there are multiple matched, how the
   best candidate will be chosen.
-  ``verbose``: Print result for individual matches
   (default=\ ``True``).

We also need to provide some specific configuration for each catalog
with:

-  ``delta_z``: Defines redshift window for matching. The possible
   values are:

   -  ``'cat'``: uses redshift properties of the catalog
   -  ``'spline.filename'``: interpolates data in ``'filename'``
      assuming (z, zmin, zmax) format
   -  ``float``: uses ``delta_z*(1+z)``
   -  ``None``: does not use z

-  ``match_radius``: Radius of the catalog to be used in the matching.
   If ``'cat'`` uses the radius in the catalog, else must be in format
   ``'value unit'``. (ex: ``'1 arcsec'``, ``'1 Mpc'``)

In this case, because one of the configuraion radius has physical units,
we need a cosmology object to convert it to angular size (this is done
internally).

.. code:: ipython3

    match_config = {
        'type': 'cross', # options are cross, cat1, cat2
        'which_radius': 'max', # Case of radius to be used, can be: cat1, cat2, min, max
        'preference': 'angular_proximity', # options are more_massive, angular_proximity or redshift_proximity
        'catalog1': {'delta_z':.2,
                    'match_radius': '1 mpc'
                    },
        'catalog2': {'delta_z':.2,
                    'match_radius': '10 arcsec'
                    }
    }
    from clevar.cosmology import AstroPyCosmology
    cosmo = AstroPyCosmology()

Once the configuration is prepared, the whole process can be done with
one call:

.. code:: ipython3

    %%time
    mt.match_from_config(c1, c2, match_config, cosmo=cosmo)


.. parsed-literal::

    
    ## ClCatalog 1
    ## Prep mt_cols
    * zmin|zmax from config value
    * ang radius from set scale
    
    ## ClCatalog 2
    ## Prep mt_cols
    * zmin|zmax from config value
    * ang radius from set scale
    
    ## Multiple match (catalog 1)
    Finding candidates (Cat1)
    * 4/5 objects matched.
    
    ## Multiple match (catalog 2)
    Finding candidates (Cat2)
    * 4/4 objects matched.
    
    ## Finding unique matches of catalog 1
    Unique Matches (Cat1)
    * 4/5 objects matched.
    
    ## Finding unique matches of catalog 2
    Unique Matches (Cat2)
    * 4/4 objects matched.
    Cross Matches (Cat1)
    * 4/5 objects matched.
    Cross Matches (Cat2)
    * 4/4 objects matched.
    CPU times: user 91.8 ms, sys: 671 µs, total: 92.5 ms
    Wall time: 90.5 ms


This will fill the matching columns in the catalogs: -
``mt_multi_self``: Multiple matches found - ``mt_multi_other``: Multiple
matches found by the other catalog - ``mt_self``: Best candidate found -
``mt_other``: Best candidate found by the other catalog - ``mt_cross``:
Best candidate found in both directions

.. code:: ipython3

    display(c1)
    display(c2)



.. raw:: html

    <b>Cat1</b><br></b><b>tags:</b> id(id), ra(ra), dec(dec), z(z), mass(mass)<br><b>Radius unit:</b> None<br><div><i>ClData length=5</i>
    <table id="table140461232734560" class="table-striped table-bordered table-condensed">
    <thead><tr><th colspan=10></th><th colspan=3 style='text-align:left; background-color:grey; color:white'>mt_input</th></tr></thread><thead><tr><th>id</th><th>ra</th><th>dec</th><th>z</th><th>mass</th><th>mt_self</th><th>mt_other</th><th>mt_multi_self</th><th>mt_multi_other</th><th>mt_cross</th><th>zmin</th><th>zmax</th><th>ang</th></tr></thead>
    <thead><tr><th>str3</th><th>float64</th><th>float64</th><th>float64</th><th>float64</th><th>object</th><th>object</th><th>object</th><th>object</th><th>object</th><th>float64</th><th>float64</th><th>float64</th></tr></thead>
    <tr><td>CL0</td><td>0.00</td><td>0.00</td><td>0.20</td><td>3.16e+13</td><td>CL0</td><td>CL0</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL0</td><td>-0.04</td><td>0.44</td><td>0.08418388522320427</td></tr>
    <tr><td>CL1</td><td>0.00</td><td>0.00</td><td>0.30</td><td>2.51e+13</td><td>CL1</td><td>CL1</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL1</td><td>0.04</td><td>0.56</td><td>0.062361611333396835</td></tr>
    <tr><td>CL2</td><td>0.00</td><td>0.00</td><td>0.25</td><td>2.00e+13</td><td>CL2</td><td>CL2</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL2</td><td>0.00</td><td>0.50</td><td>0.0710414327593546</td></tr>
    <tr><td>CL3</td><td>25.00</td><td>0.00</td><td>0.40</td><td>6.31e+13</td><td>CL3</td><td>CL3</td><td>[&apos;CL3&apos;]</td><td>[&apos;CL3&apos;]</td><td>CL3</td><td>0.12</td><td>0.68</td><td>0.05169945411341919</td></tr>
    <tr><td>CL4</td><td>20.00</td><td>0.00</td><td>0.35</td><td>1.00e+14</td><td>None</td><td>None</td><td>[]</td><td>[]</td><td>None</td><td>0.08</td><td>0.62</td><td>0.05623291641697765</td></tr>
    </table></div>



.. raw:: html

    <b>Cat2</b><br></b><b>tags:</b> id(id), ra(ra), dec(dec), z(z), mass(mass)<br><b>Radius unit:</b> None<br><div><i>ClData length=4</i>
    <table id="table140461232737152" class="table-striped table-bordered table-condensed">
    <thead><tr><th colspan=10></th><th colspan=3 style='text-align:left; background-color:grey; color:white'>mt_input</th></tr></thread><thead><tr><th>id</th><th>ra</th><th>dec</th><th>z</th><th>mass</th><th>mt_self</th><th>mt_other</th><th>mt_multi_self</th><th>mt_multi_other</th><th>mt_cross</th><th>zmin</th><th>zmax</th><th>ang</th></tr></thead>
    <thead><tr><th>str3</th><th>float64</th><th>float64</th><th>float64</th><th>float64</th><th>object</th><th>object</th><th>object</th><th>object</th><th>object</th><th>float64</th><th>float64</th><th>float64</th></tr></thead>
    <tr><td>CL0</td><td>0.00</td><td>0.00</td><td>0.30</td><td>2.00e+13</td><td>CL0</td><td>CL0</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL0</td><td>0.04</td><td>0.56</td><td>0.002777777777777778</td></tr>
    <tr><td>CL1</td><td>0.00</td><td>0.00</td><td>0.20</td><td>2.51e+13</td><td>CL1</td><td>CL1</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL1</td><td>-0.04</td><td>0.44</td><td>0.002777777777777778</td></tr>
    <tr><td>CL2</td><td>0.00</td><td>0.00</td><td>0.25</td><td>3.16e+13</td><td>CL2</td><td>CL2</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL2</td><td>0.00</td><td>0.50</td><td>0.002777777777777778</td></tr>
    <tr><td>CL3</td><td>25.00</td><td>0.00</td><td>0.40</td><td>6.31e+13</td><td>CL3</td><td>CL3</td><td>[&apos;CL3&apos;]</td><td>[&apos;CL3&apos;]</td><td>CL3</td><td>0.12</td><td>0.68</td><td>0.002777777777777778</td></tr>
    </table></div>


Save and Load
-------------

The results of the matching can easily be saved and load using
``ClEvaR`` tools:

.. code:: ipython3

    mt.save_matches(c1, c2, out_dir='temp', overwrite=True)

.. code:: ipython3

    mt.load_matches(c1, c2, out_dir='temp')
    display(c1)
    display(c2)


.. parsed-literal::

    Cat1
    << ClEvar used in matching: 0.13.0 >>
     * Total objects:    5
     * multiple (self):  4
     * multiple (other): 4
     * unique (self):    4
     * unique (other):   4
     * cross:            4
    
    Cat2
    << ClEvar used in matching: 0.13.0 >>
     * Total objects:    4
     * multiple (self):  4
     * multiple (other): 4
     * unique (self):    4
     * unique (other):   4
     * cross:            4



.. raw:: html

    <b>Cat1</b><br></b><b>tags:</b> id(id), ra(ra), dec(dec), z(z), mass(mass)<br><b>Radius unit:</b> None<br><div><i>ClData length=5</i>
    <table id="table140460607349760" class="table-striped table-bordered table-condensed">
    <thead><tr><th colspan=10></th><th colspan=3 style='text-align:left; background-color:grey; color:white'>mt_input</th></tr></thread><thead><tr><th>id</th><th>ra</th><th>dec</th><th>z</th><th>mass</th><th>mt_self</th><th>mt_other</th><th>mt_multi_self</th><th>mt_multi_other</th><th>mt_cross</th><th>zmin</th><th>zmax</th><th>ang</th></tr></thead>
    <thead><tr><th>str3</th><th>float64</th><th>float64</th><th>float64</th><th>float64</th><th>object</th><th>object</th><th>object</th><th>object</th><th>object</th><th>float64</th><th>float64</th><th>float64</th></tr></thead>
    <tr><td>CL0</td><td>0.00</td><td>0.00</td><td>0.20</td><td>3.16e+13</td><td>CL0</td><td>CL0</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL0</td><td>-0.04</td><td>0.44</td><td>0.08418388522320427</td></tr>
    <tr><td>CL1</td><td>0.00</td><td>0.00</td><td>0.30</td><td>2.51e+13</td><td>CL1</td><td>CL1</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL1</td><td>0.04</td><td>0.56</td><td>0.062361611333396835</td></tr>
    <tr><td>CL2</td><td>0.00</td><td>0.00</td><td>0.25</td><td>2.00e+13</td><td>CL2</td><td>CL2</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL2</td><td>0.00</td><td>0.50</td><td>0.0710414327593546</td></tr>
    <tr><td>CL3</td><td>25.00</td><td>0.00</td><td>0.40</td><td>6.31e+13</td><td>CL3</td><td>CL3</td><td>[&apos;CL3&apos;]</td><td>[&apos;CL3&apos;]</td><td>CL3</td><td>0.12</td><td>0.68</td><td>0.05169945411341919</td></tr>
    <tr><td>CL4</td><td>20.00</td><td>0.00</td><td>0.35</td><td>1.00e+14</td><td>None</td><td>None</td><td>[]</td><td>[]</td><td>None</td><td>0.08</td><td>0.62</td><td>0.05623291641697765</td></tr>
    </table></div>



.. raw:: html

    <b>Cat2</b><br></b><b>tags:</b> id(id), ra(ra), dec(dec), z(z), mass(mass)<br><b>Radius unit:</b> None<br><div><i>ClData length=4</i>
    <table id="table140461232736576" class="table-striped table-bordered table-condensed">
    <thead><tr><th colspan=10></th><th colspan=3 style='text-align:left; background-color:grey; color:white'>mt_input</th></tr></thread><thead><tr><th>id</th><th>ra</th><th>dec</th><th>z</th><th>mass</th><th>mt_self</th><th>mt_other</th><th>mt_multi_self</th><th>mt_multi_other</th><th>mt_cross</th><th>zmin</th><th>zmax</th><th>ang</th></tr></thead>
    <thead><tr><th>str3</th><th>float64</th><th>float64</th><th>float64</th><th>float64</th><th>object</th><th>object</th><th>object</th><th>object</th><th>object</th><th>float64</th><th>float64</th><th>float64</th></tr></thead>
    <tr><td>CL0</td><td>0.00</td><td>0.00</td><td>0.30</td><td>2.00e+13</td><td>CL0</td><td>CL0</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL0</td><td>0.04</td><td>0.56</td><td>0.002777777777777778</td></tr>
    <tr><td>CL1</td><td>0.00</td><td>0.00</td><td>0.20</td><td>2.51e+13</td><td>CL1</td><td>CL1</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL1</td><td>-0.04</td><td>0.44</td><td>0.002777777777777778</td></tr>
    <tr><td>CL2</td><td>0.00</td><td>0.00</td><td>0.25</td><td>3.16e+13</td><td>CL2</td><td>CL2</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>[&apos;CL1&apos;, &apos;CL0&apos;, &apos;CL2&apos;]</td><td>CL2</td><td>0.00</td><td>0.50</td><td>0.002777777777777778</td></tr>
    <tr><td>CL3</td><td>25.00</td><td>0.00</td><td>0.40</td><td>6.31e+13</td><td>CL3</td><td>CL3</td><td>[&apos;CL3&apos;]</td><td>[&apos;CL3&apos;]</td><td>CL3</td><td>0.12</td><td>0.68</td><td>0.002777777777777778</td></tr>
    </table></div>


Getting Matched Pairs
---------------------

There is functionality inbuilt in ``clevar`` to plot some results of the
matching, such as: - Recovery rates - Distances (anguar and redshift) of
cluster centers - Scaling relations (mass, redshift, …) for those cases,
check the match_metrics.ipynb and match_metrics_advanced.ipynb
notebooks.

If those do not provide your needs, you can get directly the matched
pairs of clusters:

.. code:: ipython3

    from clevar.match import get_matched_pairs
    mt1, mt2 = get_matched_pairs(c1, c2, 'cross')

These will be catalogs with the corresponding matched pairs:

.. code:: ipython3

    import pylab as plt
    plt.scatter(mt1['mass'], mt2['mass'])




.. parsed-literal::

    <matplotlib.collections.PathCollection at 0x7fbf8893bf10>




.. image:: proximity_matching_files/proximity_matching_22_1.png


Outputing matched catalogs
--------------------------

To save the current catalogs, you can use the ``write`` inbuilt
function:

.. code:: ipython3

    c1.write('c1_temp.fits', overwrite=True)

This will allow you to save the catalog with its current labels and
matching information.

Outputing matching information to original catalogs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your input data came from initial files, ``clevar`` also provides
functions create output files that combine all the information on them
with the matching results.

To add the matching information to an input catalog, use:

::

   from clevar.match import output_catalog_with_matching
   output_catalog_with_matching('input_catalog.fits', 'output_catalog.fits', c1)

-  note: ``input_catalog.fits`` must have the same number of rows that
   ``c1``.

To create a matched catalog containig all columns of both input
catalogs, use:

::

   from clevar.match import output_matched_catalog
   output_matched_catalog('input_catalog1.fits', 'input_catalog2.fits',
       'output_catalog.fits', c1, c2, matching_type='cross')

where ``matching_type`` must be ``cross``, ``cat1`` or ``cat2``.

-  note: ``input_catalog1.fits`` must have the same number of rows that
   ``c1`` (and the same for ``c2``).

