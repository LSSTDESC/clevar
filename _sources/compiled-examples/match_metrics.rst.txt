Metrics of matching (simple)
============================

Example of the functions to plot match_metrics of matching.

.. code:: ipython3

    %load_ext autoreload
    %autoreload 2

.. code:: ipython3

    import numpy as np
    import pylab as plt

Generate random data and add to catalog
---------------------------------------

.. code:: ipython3

    # For reproducibility
    np.random.seed(1)

.. code:: ipython3

    from support import gen_cluster
    input1, input2 = gen_cluster()

.. code:: ipython3

    from clevar import ClCatalog
    c1 = ClCatalog('Cat1', ra=input1['RA'], dec=input1['DEC'], z=input1['Z'], mass=input1['MASS'],
                mass_err=input1['MASS_ERR'], z_err=input1['Z_ERR'])
    c2 = ClCatalog('Cat2', ra=input2['RA'], dec=input2['DEC'], z=input2['Z'], mass=input2['MASS'],
                mass_err=input2['MASS_ERR'], z_err=input2['Z_ERR'])
    # Format for nice display
    for c in ('ra', 'dec', 'z', 'z_err'):
        c1[c].info.format = '.2f'
        c2[c].info.format = '.2f'
    for c in ('mass', 'mass_err'):
        c1[c].info.format = '.2e'
        c2[c].info.format = '.2e'

Match catalogs
--------------

.. code:: ipython3

    from clevar.match import ProximityMatch
    from clevar.cosmology import AstroPyCosmology
    
    match_config = {
        'type': 'cross', # options are cross, cat1, cat2
        'which_radius': 'max', # Case of radius to be used, can be: cat1, cat2, min, max
        'preference': 'angular_proximity', # options are more_massive, angular_proximity or redshift_proximity
        'catalog1': {'delta_z':.2,
                    'match_radius': '1 mpc'
                    },
        'catalog2': {'delta_z':.2,
                    'match_radius': '10 arcsec'
                    }
    }
    
    cosmo = AstroPyCosmology()
    mt = ProximityMatch()
    mt.match_from_config(c1, c2, match_config, cosmo=cosmo)


.. parsed-literal::

    
    ## ClCatalog 1
    ## Prep mt_cols
    * zmin|zmax from config value
    * ang radius from set scale
    
    ## ClCatalog 2
    ## Prep mt_cols
    * zmin|zmax from config value
    * ang radius from set scale
    
    ## Multiple match (catalog 1)
    Finding candidates (Cat1)
    * 400/700 objects matched.
    
    ## Multiple match (catalog 2)
    Finding candidates (Cat2)
    * 400/700 objects matched.
    
    ## Finding unique matches of catalog 1
    Unique Matches (Cat1)
    * 400/700 objects matched.
    
    ## Finding unique matches of catalog 2
    Unique Matches (Cat2)
    * 400/700 objects matched.
    Cross Matches (Cat1)
    * 400/700 objects matched.
    Cross Matches (Cat2)
    * 400/700 objects matched.


Recovery rate
-------------

Compute recovery rates, they are computed in mass and redshift bins.
There are several ways they can be displayed: - Single panel with
multiple lines - Multiple panels - 2D color map

.. code:: ipython3

    from clevar.match_metrics import recovery

.. code:: ipython3

    zbins = np.linspace(0, 2, 6)
    mbins = np.logspace(13, 14, 5)

Simple plot
~~~~~~~~~~~

The recovery rates are shown as a function of redshift in mass bins.
They can be displayed as a continuous line or with steps:

.. code:: ipython3

    ax = recovery.plot(c1, 'cross', zbins, mbins)
    plt.show()
    ax = recovery.plot(c1, 'cross', zbins, mbins, shape='line')
    plt.show()



.. image:: match_metrics_files/match_metrics_13_0.png



.. image:: match_metrics_files/match_metrics_13_1.png


They can also be transposed to be shown as a function of mass in
redshift bins.

.. code:: ipython3

    ax = recovery.plot(c1, 'cross', zbins, mbins,
                  shape='line', transpose=True)



.. image:: match_metrics_files/match_metrics_15_0.png


Panels plots
~~~~~~~~~~~~

You can also have a panel for each bin:

.. code:: ipython3

    f, axes = recovery.plot_panel(c1, 'cross', zbins, mbins)
    f, axes = recovery.plot_panel(c1, 'cross', zbins, mbins, transpose=True)



.. image:: match_metrics_files/match_metrics_17_0.png



.. image:: match_metrics_files/match_metrics_17_1.png


2D plots
~~~~~~~~

.. code:: ipython3

    ax = recovery.plot2D(c1, 'cross', zbins, mbins)
    plt.show()
    ax = recovery.plot2D(c1, 'cross', zbins, mbins,
                    add_num=True, num_kwargs={'fontsize':15})



.. image:: match_metrics_files/match_metrics_19_0.png



.. image:: match_metrics_files/match_metrics_19_1.png


Distances of matching
---------------------

Here we evaluate the distance between the cluster centers and their
redshifts. These distances can be shown for all matched clusters, or in
bins:

.. code:: ipython3

    from clevar.match_metrics import distances

.. code:: ipython3

    ax = distances.central_position(c1, c2, 'cross', radial_bins=20, radial_bin_units='degrees')



.. image:: match_metrics_files/match_metrics_22_0.png


.. code:: ipython3

    ax = distances.central_position(c1, c2, 'cross', radial_bins=20, radial_bin_units='degrees',
                                    quantity_bins='mass', bins=mbins, log_quantity=True)



.. image:: match_metrics_files/match_metrics_23_0.png


.. code:: ipython3

    ax = distances.central_position(c1, c2, 'cross', radial_bins=20, radial_bin_units='degrees',
                                    quantity_bins='z', bins=zbins[::2], log_quantity=False)



.. image:: match_metrics_files/match_metrics_24_0.png


.. code:: ipython3

    ax = distances.redshift(c1, c2, 'cross', redshift_bins=20, normalize='cat1')



.. image:: match_metrics_files/match_metrics_25_0.png


.. code:: ipython3

    ax = distances.redshift(c1, c2, 'cross', redshift_bins=20, normalize='cat1',
                            quantity_bins='mass', bins=mbins, log_quantity=True)



.. image:: match_metrics_files/match_metrics_26_0.png


.. code:: ipython3

    ax = distances.redshift(c1, c2, 'cross', redshift_bins=20, normalize='cat1',
                            quantity_bins='z', bins=zbins[::2], log_quantity=False)



.. image:: match_metrics_files/match_metrics_27_0.png


Scaling Relations
-----------------

.. code:: ipython3

    from clevar.match_metrics import scaling

Redshift plots
~~~~~~~~~~~~~~

Simple plot
^^^^^^^^^^^

.. code:: ipython3

    ax = scaling.redshift(c1, c2, 'cross')



.. image:: match_metrics_files/match_metrics_32_0.png


Color points by :math:`\log(M)` value
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: ipython3

    ax, cb = scaling.redshift_masscolor(c1, c2, 'cross', add_err=True)



.. image:: match_metrics_files/match_metrics_34_0.png


Color points by density at plot
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: ipython3

    ax, cb = scaling.redshift_density(c1, c2, 'cross', add_err=True)



.. image:: match_metrics_files/match_metrics_36_0.png


.. code:: ipython3

    ax, cb = scaling.redshift_density(c1, c2, 'cross', ax_rotation=45)



.. image:: match_metrics_files/match_metrics_37_0.png


Evaluate metrics of the distribution
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: ipython3

    fig, axes = scaling.redshift_metrics(c1, c2, 'cross')



.. image:: match_metrics_files/match_metrics_39_0.png


.. code:: ipython3

    fig, axes = scaling.redshift_density_metrics(c1, c2, 'cross', ax_rotation=45)



.. image:: match_metrics_files/match_metrics_40_0.png


Split data into mass bins
^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: ipython3

    fig, axes = scaling.redshift_masspanel(c1, c2, 'cross', add_err=True)



.. image:: match_metrics_files/match_metrics_42_0.png


Split data into mass bins and color by density
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: ipython3

    fig, axes = scaling.redshift_density_masspanel(c1, c2, 'cross', add_err=True)



.. image:: match_metrics_files/match_metrics_44_0.png


Evaluate the distribution
^^^^^^^^^^^^^^^^^^^^^^^^^

See how the distribution of mass happens in each bin for one of the
catalogs

.. code:: ipython3

    %%time
    fig, axes = scaling.redshift_dist_self(c2, redshift_bins_dist=21,
                                  mass_bins=[10**13.0, 10**13.2, 10**13.5, 1e15],
                                  redshift_bins=4, shape='line',
                                  fig_kwargs={'figsize':(15, 6)})


.. parsed-literal::

    CPU times: user 188 ms, sys: 208 ms, total: 396 ms
    Wall time: 132 ms



.. image:: match_metrics_files/match_metrics_46_1.png


Compare with the distribution on the other catalog

.. code:: ipython3

    %%time
    fig, axes = scaling.redshift_dist(c1, c2, 'cross', redshift_bins_dist=21,
                                  mass_bins=[10**13.0, 10**13.2, 10**13.5, 1e15],
                                  redshift_bins=4, shape='line',
                                  fig_kwargs={'figsize':(15, 6)})


.. parsed-literal::

    CPU times: user 394 ms, sys: 229 ms, total: 623 ms
    Wall time: 355 ms



.. image:: match_metrics_files/match_metrics_48_1.png


Mass plots
~~~~~~~~~~

Simple plot
^^^^^^^^^^^

.. code:: ipython3

    ax = scaling.mass(c1, c2, 'cross', add_err=True, add_fit=True, fit_bins1=30)


::


    ---------------------------------------------------------------------------

    IndexError                                Traceback (most recent call last)

    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/pyparsing.py in _parseNoCache(self, instring, loc, doActions, callPreParse)
       1682                 try:
    -> 1683                     loc, tokens = self.parseImpl(instring, preloc, doActions)
       1684                 except IndexError:


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/pyparsing.py in parseImpl(self, instring, loc, doActions)
       2890     def parseImpl(self, instring, loc, doActions=True):
    -> 2891         if instring[loc] == self.firstMatchChar and instring.startswith(self.match, loc):
       2892             return loc + self.matchLen, self.match


    IndexError: string index out of range

    
    During handling of the above exception, another exception occurred:


    ParseException                            Traceback (most recent call last)

    ParseException: Expected "\right", found end of text  (at char 6), (line:1, col:7)

    
    During handling of the above exception, another exception occurred:


    ParseSyntaxException                      Traceback (most recent call last)

    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/mathtext.py in parse(self, s, fonts_object, fontsize, dpi)
       2608         try:
    -> 2609             result = self._expression.parseString(s)
       2610         except ParseBaseException as err:


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/pyparsing.py in parseString(self, instring, parseAll)
       1954                     exc.__traceback__ = self._trim_traceback(exc.__traceback__)
    -> 1955                 raise exc
       1956         else:


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/pyparsing.py in parseImpl(self, instring, loc, doActions)
       4064                     pe.__traceback__ = None
    -> 4065                     raise ParseSyntaxException._from_exception(pe)
       4066                 except IndexError:


    ParseSyntaxException: Expected "\right", found end of text  (at char 6), (line:1, col:7)

    
    The above exception was the direct cause of the following exception:


    ValueError                                Traceback (most recent call last)

    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/IPython/core/formatters.py in __call__(self, obj)
        339                 pass
        340             else:
    --> 341                 return printer(obj)
        342             # Finally look for special method names
        343             method = get_real_method(obj, self.print_method)


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/IPython/core/pylabtools.py in <lambda>(fig)
        246 
        247     if 'png' in formats:
    --> 248         png_formatter.for_type(Figure, lambda fig: print_figure(fig, 'png', **kwargs))
        249     if 'retina' in formats or 'png2x' in formats:
        250         png_formatter.for_type(Figure, lambda fig: retina_figure(fig, **kwargs))


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/IPython/core/pylabtools.py in print_figure(fig, fmt, bbox_inches, **kwargs)
        130         FigureCanvasBase(fig)
        131 
    --> 132     fig.canvas.print_figure(bytes_io, **kw)
        133     data = bytes_io.getvalue()
        134     if fmt == 'svg':


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/backend_bases.py in print_figure(self, filename, dpi, facecolor, edgecolor, orientation, format, bbox_inches, pad_inches, bbox_extra_artists, backend, **kwargs)
       2191                            else suppress())
       2192                     with ctx:
    -> 2193                         self.figure.draw(renderer)
       2194 
       2195                     bbox_inches = self.figure.get_tightbbox(


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/artist.py in draw_wrapper(artist, renderer, *args, **kwargs)
         39                 renderer.start_filter()
         40 
    ---> 41             return draw(artist, renderer, *args, **kwargs)
         42         finally:
         43             if artist.get_agg_filter() is not None:


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/figure.py in draw(self, renderer)
       1861 
       1862             self.patch.draw(renderer)
    -> 1863             mimage._draw_list_compositing_images(
       1864                 renderer, self, artists, self.suppressComposite)
       1865 


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/image.py in _draw_list_compositing_images(renderer, parent, artists, suppress_composite)
        129     if not_composite or not has_images:
        130         for a in artists:
    --> 131             a.draw(renderer)
        132     else:
        133         # Composite any adjacent images together


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/artist.py in draw_wrapper(artist, renderer, *args, **kwargs)
         39                 renderer.start_filter()
         40 
    ---> 41             return draw(artist, renderer, *args, **kwargs)
         42         finally:
         43             if artist.get_agg_filter() is not None:


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/cbook/deprecation.py in wrapper(*inner_args, **inner_kwargs)
        409                          else deprecation_addendum,
        410                 **kwargs)
    --> 411         return func(*inner_args, **inner_kwargs)
        412 
        413     return wrapper


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/axes/_base.py in draw(self, renderer, inframe)
       2745             renderer.stop_rasterizing()
       2746 
    -> 2747         mimage._draw_list_compositing_images(renderer, self, artists)
       2748 
       2749         renderer.close_group('axes')


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/image.py in _draw_list_compositing_images(renderer, parent, artists, suppress_composite)
        129     if not_composite or not has_images:
        130         for a in artists:
    --> 131             a.draw(renderer)
        132     else:
        133         # Composite any adjacent images together


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/artist.py in draw_wrapper(artist, renderer, *args, **kwargs)
         39                 renderer.start_filter()
         40 
    ---> 41             return draw(artist, renderer, *args, **kwargs)
         42         finally:
         43             if artist.get_agg_filter() is not None:


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/legend.py in draw(self, renderer)
        604         # update the location and size of the legend. This needs to
        605         # be done in any case to clip the figure right.
    --> 606         bbox = self._legend_box.get_window_extent(renderer)
        607         self.legendPatch.set_bounds(bbox.x0, bbox.y0, bbox.width, bbox.height)
        608         self.legendPatch.set_mutation_scale(fontsize)


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in get_window_extent(self, renderer)
        344     def get_window_extent(self, renderer):
        345         """Return the bounding box (`.Bbox`) in display space."""
    --> 346         w, h, xd, yd, offsets = self.get_extent_offsets(renderer)
        347         px, py = self.get_offset(w, h, xd, yd, renderer)
        348         return mtransforms.Bbox.from_bounds(px - xd, py - yd, w, h)


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in get_extent_offsets(self, renderer)
        469                     c.set_width(self.width)
        470 
    --> 471         whd_list = [c.get_extent(renderer)
        472                     for c in self.get_visible_children()]
        473         whd_list = [(w, h, xd, (h - yd)) for w, h, xd, yd in whd_list]


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in <listcomp>(.0)
        469                     c.set_width(self.width)
        470 
    --> 471         whd_list = [c.get_extent(renderer)
        472                     for c in self.get_visible_children()]
        473         whd_list = [(w, h, xd, (h - yd)) for w, h, xd, yd in whd_list]


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in get_extent(self, renderer)
        339     def get_extent(self, renderer):
        340         """Return a tuple ``width, height, xdescent, ydescent`` of the box."""
    --> 341         w, h, xd, yd, offsets = self.get_extent_offsets(renderer)
        342         return w, h, xd, yd
        343 


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in get_extent_offsets(self, renderer)
        542         sep = self.sep * dpicor
        543 
    --> 544         whd_list = [c.get_extent(renderer)
        545                     for c in self.get_visible_children()]
        546 


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in <listcomp>(.0)
        542         sep = self.sep * dpicor
        543 
    --> 544         whd_list = [c.get_extent(renderer)
        545                     for c in self.get_visible_children()]
        546 


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in get_extent(self, renderer)
        339     def get_extent(self, renderer):
        340         """Return a tuple ``width, height, xdescent, ydescent`` of the box."""
    --> 341         w, h, xd, yd, offsets = self.get_extent_offsets(renderer)
        342         return w, h, xd, yd
        343 


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in get_extent_offsets(self, renderer)
        469                     c.set_width(self.width)
        470 
    --> 471         whd_list = [c.get_extent(renderer)
        472                     for c in self.get_visible_children()]
        473         whd_list = [(w, h, xd, (h - yd)) for w, h, xd, yd in whd_list]


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in <listcomp>(.0)
        469                     c.set_width(self.width)
        470 
    --> 471         whd_list = [c.get_extent(renderer)
        472                     for c in self.get_visible_children()]
        473         whd_list = [(w, h, xd, (h - yd)) for w, h, xd, yd in whd_list]


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in get_extent(self, renderer)
        339     def get_extent(self, renderer):
        340         """Return a tuple ``width, height, xdescent, ydescent`` of the box."""
    --> 341         w, h, xd, yd, offsets = self.get_extent_offsets(renderer)
        342         return w, h, xd, yd
        343 


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in get_extent_offsets(self, renderer)
        542         sep = self.sep * dpicor
        543 
    --> 544         whd_list = [c.get_extent(renderer)
        545                     for c in self.get_visible_children()]
        546 


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in <listcomp>(.0)
        542         sep = self.sep * dpicor
        543 
    --> 544         whd_list = [c.get_extent(renderer)
        545                     for c in self.get_visible_children()]
        546 


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/offsetbox.py in get_extent(self, renderer)
        884             "lp", self._text._fontproperties, ismath=False)
        885 
    --> 886         bbox, info, d = self._text._get_layout(renderer)
        887         w, h = bbox.width, bbox.height
        888 


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/text.py in _get_layout(self, renderer)
        293             clean_line, ismath = self._preprocess_math(line)
        294             if clean_line:
    --> 295                 w, h, d = renderer.get_text_width_height_descent(
        296                     clean_line, self._fontproperties, ismath=ismath)
        297             else:


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/backends/backend_agg.py in get_text_width_height_descent(self, s, prop, ismath)
        231         if ismath:
        232             ox, oy, width, height, descent, fonts, used_characters = \
    --> 233                 self.mathtext_parser.parse(s, self.dpi, prop)
        234             return width, height, descent
        235 


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/mathtext.py in parse(self, s, dpi, prop)
       3330         # mathtext.fontset rcParams also affect the parse (e.g. by affecting
       3331         # the glyph metrics).
    -> 3332         return self._parse_cached(
       3333             s, dpi, prop, rcParams['ps.useafm'], rcParams['mathtext.fontset'])
       3334 


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/mathtext.py in _parse_cached(self, s, dpi, prop, ps_useafm, fontset)
       3354             self.__class__._parser = Parser()
       3355 
    -> 3356         box = self._parser.parse(s, font_output, fontsize, dpi)
       3357         font_output.set_canvas_size(box.width, box.height, box.depth)
       3358         return font_output.get_results(box)


    ~/miniconda3/envs/clmmenv/lib/python3.9/site-packages/matplotlib/mathtext.py in parse(self, s, fonts_object, fontsize, dpi)
       2609             result = self._expression.parseString(s)
       2610         except ParseBaseException as err:
    -> 2611             raise ValueError("\n".join(["",
       2612                                         err.line,
       2613                                         " " * (err.column - 1) + "^",


    ValueError: 
    \left<
          ^
    Expected "\right", found end of text  (at char 6), (line:1, col:7)



.. parsed-literal::

    <Figure size 432x288 with 1 Axes>


Color points by redshift value
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: ipython3

    ax, cb = scaling.mass_zcolor(c1, c2, 'cross', add_err=True)



.. image:: match_metrics_files/match_metrics_53_0.png


Color points by density at plot
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: ipython3

    ax, cb = scaling.mass_density(c1, c2, 'cross', add_err=True)



.. image:: match_metrics_files/match_metrics_55_0.png


Split data into redshift bins
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: ipython3

    fig, axes = scaling.mass_zpanel(c1, c2, 'cross', add_err=True)



.. image:: match_metrics_files/match_metrics_57_0.png


Split data into redshift bins and color by density
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: ipython3

    fig, axes = scaling.mass_density_zpanel(c1, c2, 'cross', add_err=True)



.. image:: match_metrics_files/match_metrics_59_0.png


Evaluate metrics of the distribution
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code:: ipython3

    fig, axes = scaling.mass_metrics(c1, c2, 'cross')



.. image:: match_metrics_files/match_metrics_61_0.png


.. code:: ipython3

    fig, axes = scaling.mass_density_metrics(c1, c2, 'cross', ax_rotation=45)



.. image:: match_metrics_files/match_metrics_62_0.png


Evaluate the distribution
^^^^^^^^^^^^^^^^^^^^^^^^^

See how the distribution of mass happens in each bin for one of the
catalogs

.. code:: ipython3

    %%time
    fig, axes = scaling.mass_dist_self(c2, mass_bins_dist=21,
                                  mass_bins=[10**13.0, 10**13.2, 10**13.5, 1e14, 1e15],
                                  redshift_bins=4, shape='line',
                                  fig_kwargs={'figsize':(15, 6)})


.. parsed-literal::

    CPU times: user 155 ms, sys: 165 ms, total: 320 ms
    Wall time: 127 ms



.. image:: match_metrics_files/match_metrics_64_1.png


Compare with the distribution on the other catalog

.. code:: ipython3

    %%time
    fig, axes = scaling.mass_dist(c1, c2, 'cross', mass_bins_dist=21,
                                  mass_bins=[10**13.0, 10**13.2, 10**13.5, 1e14, 1e15],
                                  redshift_bins=4, shape='line',
                                  fig_kwargs={'figsize':(15, 6)})


.. parsed-literal::

    CPU times: user 411 ms, sys: 189 ms, total: 600 ms
    Wall time: 333 ms



.. image:: match_metrics_files/match_metrics_66_1.png

